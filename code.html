<p>#include <Servo.h>

int trigPin = 7;
int echoPin = 6;

int redPin = 11;
int greenPin = 10;
int bluePin = 12;

int buzzerPin = 8;
int servoPin = 13;

long time;
float distance;
static float prevDistance = 0;

float range = 0;  

Servo myServo;

int servoPos = 0;
int servoDirection = 1; 
int servoMin = 10;
int servoMax = 170;

unsigned long lastServoMove = 0;
unsigned long servoInterval = 20;

bool alertMode = false;
unsigned long alertStart = 0;
unsigned long alertDuration = 10000;

bool panicPending = false;
unsigned long panicTimerStart = 0;
const unsigned long panicWaitTime = 6000;

bool rangeSet = false;
unsigned long setupStartTime;

void setup() {
  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);

  pinMode(redPin, OUTPUT);
  pinMode(greenPin, OUTPUT);
  pinMode(bluePin, OUTPUT);

  pinMode(buzzerPin, OUTPUT);

  myServo.attach(servoPin);
  myServo.write(servoMin);

  Serial.begin(9600);
  setupStartTime = millis();
}

void loop() {
  if (!rangeSet && millis() - setupStartTime >= 3000) { 
    range = measureDistance();
    rangeSet = true;
    Serial.print("Fixed range set to: ");
    Serial.println(range);
  }

  distance = measureDistance();

  Serial.print("Distance: ");
  Serial.println(distance);

  if (rangeSet) {
    if (abs(distance - prevDistance) > 4 || distance > range + 15) {
      if (!panicPending && !alertMode) {
        panicPending = true;
        panicTimerStart = millis();
        Serial.println("Warning detected...");
      }
    } else {
      if (panicPending) {
        Serial.println("Warning cancelled - object back in range.");
        panicPending = false;
      }
    }

    if (panicPending) {
      if (millis() - panicTimerStart >= panicWaitTime) {
        if (!alertMode) {
          alertMode = true;
          alertStart = millis();
          Serial.println("ALERT! Panic triggered!");
          tone(buzzerPin, 1000); 
        }
      }
    }

    if (alertMode) {
      alertRGB(255, 0, 0);
      myServo.write(90);
      if (millis() - alertStart > alertDuration) {
        alertMode = false;
        panicPending = false;
        noTone(buzzerPin);
        Serial.println("Alert ended.");
      }
    } else {
      alertRGB(0, 255, 0);
      moveServoSmooth();
    }
  }

  prevDistance = distance;
  delay(50);
}

float measureDistance() {
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);

  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);

  time = pulseIn(echoPin, HIGH);
  return time * 0.0343 / 2;
}

void moveServoSmooth() {
  unsigned long currentMillis = millis();
  if (currentMillis - lastServoMove >= servoInterval) {
    servoPos += servoDirection;
    if (servoPos >= servoMax) {
      servoPos = servoMax;
      servoDirection = -1;
    } else if (servoPos <= servoMin) {
      servoPos = servoMin;
      servoDirection = 1;
    }
    myServo.write(servoPos);
    lastServoMove = currentMillis;
  }
}

void alertRGB(int r, int g, int b) {
  analogWrite(redPin, r);
  analogWrite(greenPin, g);
  analogWrite(bluePin, b);
}</p>
